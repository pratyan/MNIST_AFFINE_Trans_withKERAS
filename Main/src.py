# -*- coding: utf-8 -*-
"""AFFINE_Trans_Keras_onMNIST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u9m_4c4m4BFgqv5YoL88nDeHHePyywpR
"""

import tensorflow as tf
import matplotlib.pyplot as plt
import numpy as np
import scipy
import tensorflow_probability as tfp

from scipy.ndimage import affine_transform

(x_train,y_train), (x_test,y_test) = tf.keras.datasets.mnist.load_data()

def affine_transformation(img):

  #centroid
  x,y = np.mgrid[:28,:28]

  cen_x  = np.sum(x*img)/np.sum(img)
  cen_y = np.sum(y*img)/np.sum(img)

  #covariance_matrix
  X = np.sum((x - cen_x)**2*img)/np.sum(img)
  Y = np.sum((y - cen_y)**2*img)/np.sum(img)
  XY = np.sum((x - cen_x)*(y - cen_y)*img)/np.sum(img)

  cov = [[X,XY],[XY,Y]]

  #correlation_matrix
  corr = XY/X 
  correlation_matrix = [[1,0],[corr,1]]

  #OFFSET
  Offset=[cen_x,cen_y]-np.dot(correlation_matrix,[14,14])

  #Image after Affine_transform
  rotate=affine_transform(img,correlation_matrix,offset=Offset)

  return rotate

#Transformed dataset
x_train_trans = []
x_test_trans = []

for i in range(60000):
  rotate = affine_transformation(x_train[i])
  x_train_trans.append(rotate)

for i in range(10000):
  rotate = affine_transformation(x_test[i])
  x_test_trans.append(rotate)


x_train_trans = tf.convert_to_tensor(x_train_trans, dtype=tf.float32)
x_test_trans = tf.convert_to_tensor(x_test_trans, dtype=tf.float32)

#KERAS model
def ProbRegression():
  input = tf.keras.layers.Flatten(input_shape=(28,28))
  output = tf.keras.layers.Dense(10, activation=tfp.bijectors.NormalCDF())
  layers=[input,output]
  model=tf.keras.Sequential(layers)
  model.compile(loss='SparseCategoricalCrossentropy', optimizer='adam',metrics='accuracy')
  return model

Model = ProbRegression()
Model.fit(x_train_trans/255,y_train,epochs=200,validation_data=(x_test_trans/255,y_test))
